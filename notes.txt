529 комната где живет мальчик который все делает

---10---

Программа печатает информацию о появлении новых файлов в указанном каталоге
в том числе перенесенные
Отслеживаем эти события с помощью identify.

inotify (dnetify устаревший, kqueue...) - механизм чтобы подписаться на то что происходит с файлом
1) создать очередь событий
события, которые интересуют: создание открытие удаление прееименование
есть еще fanotify

inotify_add_watch подписываемся
inotify_init создание очереди и (ее просмотр?)
с помощью read читаем очередь в вечном цикле и выводим в printf

---11---

Программа выводит количество запусков (считая текущий), отслеживая их количество в текстовом
файле counter.txt и корректно обрабатывая параллельные запуски, нуждо устанавливать блокировку
на файл (не flock, a lockf)

Файловые блокировки:
advisory(рекомендательные) or mandatory (обязательные)
    |                \
    V                 V
shared(reader lock)  exclusive(writer work)
Когда блокировку удается схватить нужно скорее закончить работу и отпустить.
Есть man 2 flock но единственный его плюс что он есть везде. Минусы: блокировка сразу на весь
файл, работает не на всех
Есть lockf (POSIX): +: захват области, могут разные люди одновременно
Есть fcntl название механизма

ps список процессов
man 7 credentials
wait\ waitpid \ waitid чтобы ждать завершения процесса потомка или группу процессов потомков
PID process identifier, PPID parent PID.
ulimit -a

ferror
fprintf пишет сначала в буфер, может и после закрытия файла fflush чтобы очистить буфер

---12---

выводит информацию которая рассказывает о запущенном экземпляре программы
man 7 sched планирование процессов, приоритеты
19:19 12 октября фто проги
getgrous чтобы было написано user те имя
namespace

---13---
1 порождает дочерний процесс использует waitpid/waitid для ожидания завершения
использовать wait\ waitpid \ waitid чтобы ждать завершения процесса потомка или группу процессов потомков
затем выводит информацию о завершении
2 дочерний ждет родительского завершения (ptraice/pidfd_open+read)
подсказка на фото 12 октября в названии общих задач
например pidfd_open

порождение процессов: плохой вариант CreateProcess- с нуля конструирует процесс, но иногда другого
варианта нет; хороший на юникс системах - распилить на две отдельных операции: создание нового
процесса fork создает просто копию нашего текущего процесса: взодит один а выходит два
процесса - отличаются идентификаторы и родительские идентификаторы. Один делает одну часть
задачи, второй - вторую. Время уменьшается в 2 раза, так как работают параллельно. Код остается
старый. Если хочется чтобы работала другая программа сначала fork+execve. posix_spawn то же
самое но без копирования. Две последние - запуск другой программы в новом процессе

cor dump / core файл в который записывается информация памяти после завершения программы, можно сотреть
почему программа упала


---15---
signal/sigaction
Следующий способ межпроцессного взаимодействия - сигнал, отправляют число с помощью kill. Когда сигнал
посылается процессу - может убить, может перед смертью записать core dump. Смысл сигналов - передать инфу
fg возвращает из спячки
kill -9 убийство в любом случае

signalfd sigkill одновременные сигналы

---21---
есть много проблем: клиент не удаляет вышедших, не может отправлять пока клиент
 первым не отправит
Используют протоколы TCP, где есть служебные поля, здесь появляются состояния у сокета,
появляются соединения

UDP
